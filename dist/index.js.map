{"version":3,"sources":["../src/commands/add.ts","../src/utils/spinner.ts","../src/utils/updaters/update-files.ts","../src/utils/get-project-info.ts","../src/utils/get-config.ts","../src/utils/get-package-info.ts","../src/utils/add-components.ts","../src/commands/diff.ts","../src/utils/transformers/index.ts","../src/utils/transformers/transform-jsx.ts","../src/commands/info.ts","../src/index.ts","../package.json"],"names":["path","ora","spinner","text","options","existsSync","fs","basename","cosmiconfig","fg","z","explorer","rawConfigSchema","configSchema","workspaceConfigSchema","getConfig","cwd","config","getRawConfig","resolveConfigPaths","logger","highlighter","componentPath","loadConfig","TS_CONFIG_SCHEMA","getProjectInfo","isSrcDir","prompts","updateFiles","files","filesCreatedSpinner","projectInfo","filesCreated","filesUpdated","filesSkipped","file","filePath","resolveFilePath","findCommonRoot","f","fileName","targetDir","existingFile","content","existingFileContent","normalizedExisting","normalizedNew","getNormalizedFileContent","overwrite","paths","needle","normalizedPaths","p","normalizedNeedle","needleDir","needleSegments","i","testPath","addComponents","components","addProjectComponents","registrySpinner","tree","registryResolveItemsTree","handleError","Command","addOptionsSchema","add","opts","promptForRegistryComponents","error","registryIndex","getRegistryIndex","entry","result","tmpdir","transformFromAstSync","parse","transformTypescript","recast","PARSE_OPTIONS","transformJsx","sourceFile","output","ast","code","Project","ScriptKind","project","createTempSourceFile","filename","dir","transform","transformers","tempFile","transformer","diffLines","updateOptionsSchema","diff","name","projectComponents","item","componentsWithUpdates","component","changes","diffComponent","change","printDiff","payload","fetchTree","getItemTargetPath","fileContent","registryContent","patch","part","info","package_default","main","program"],"mappings":"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","sourcesContent":["import path from \"path\"\nimport { runInit } from \"@/src/commands/init\"\nimport { preFlightAdd } from \"@/src/preflights/preflight-add\"\nimport { getRegistryIndex } from \"@/src/registry/api\"\nimport { addComponents } from \"@/src/utils/add-components\"\nimport { createProject } from \"@/src/utils/create-project\"\nimport * as ERRORS from \"@/src/utils/errors\"\nimport { getConfig } from \"@/src/utils/get-config\"\nimport { handleError } from \"@/src/utils/handle-error\"\nimport { highlighter } from \"@/src/utils/highlighter\"\nimport { logger } from \"@/src/utils/logger\"\nimport { Command } from \"commander\"\nimport prompts from \"prompts\"\nimport { z } from \"zod\"\n\nconst DEPRECATED_COMPONENTS = [\n  {\n    name: \"toast\",\n    deprecatedBy: \"sonner\",\n    message:\n      \"The toast component is deprecated. Use the sonner component instead.\",\n  },\n  {\n    name: \"toaster\",\n    deprecatedBy: \"sonner\",\n    message:\n      \"The toaster component is deprecated. Use the sonner component instead.\",\n  },\n]\n\nexport const addOptionsSchema = z.object({\n  components: z.array(z.string()).optional(),\n  yes: z.boolean(),\n  overwrite: z.boolean(),\n  cwd: z.string(),\n  all: z.boolean(),\n  path: z.string().optional(),\n  silent: z.boolean(),\n  srcDir: z.boolean().optional(),\n  cssVariables: z.boolean(),\n  skipPreflight: z.boolean().optional(),\n})\n\nexport const add = new Command()\n  .name(\"add\")\n  .description(\"add a component to your project\")\n  .argument(\n    \"[components...]\",\n    \"the components to add or a url to the component.\"\n  )\n  .option(\"-y, --yes\", \"skip confirmation prompt.\", false)\n  .option(\"-o, --overwrite\", \"overwrite existing files.\", false)\n  .option(\n    \"-c, --cwd <cwd>\",\n    \"the working directory. defaults to the current directory.\",\n    process.cwd()\n  )\n  .option(\"-a, --all\", \"add all available components\", false)\n  .option(\"-p, --path <path>\", \"the path to add the component to.\")\n  .option(\"-s, --silent\", \"mute output.\", false)\n  .option(\n    \"--src-dir\",\n    \"use the src directory when creating a new project.\",\n    false\n  )\n  .option(\n    \"--no-src-dir\",\n    \"do not use the src directory when creating a new project.\"\n  )\n  .option(\"--css-variables\", \"use css variables for theming.\", true)\n  .option(\"--no-css-variables\", \"do not use css variables for theming.\")\n  .option(\"--skip-preflight\", \"skip preflight checks for components.json and tailwind config\")\n  .action(async (components, opts) => {\n    try {\n      const options = addOptionsSchema.parse({\n        components,\n        cwd: path.resolve(opts.cwd),\n        ...opts,\n      })\n\n      if (!options.components?.length) {\n        options.components = await promptForRegistryComponents(options)\n      }\n      console.log(\"options.components\", options.components)\n\n      const config = await getConfig(options.cwd)\n      if (!config) {\n        logger.break()\n        handleError(new Error(\"Failed to get config.\"))\n        return\n      }\n\n      await addComponents(options.components, config, options)\n    } catch (error) {\n      logger.break()\n      handleError(error)\n    }\n  })\n\nasync function promptForRegistryComponents(\n  options: z.infer<typeof addOptionsSchema>\n) {\n  const registryIndex = await getRegistryIndex()\n  if (!registryIndex) {\n    logger.break()\n    handleError(new Error(\"Failed to fetch registry index.\"))\n    return []\n  }\n\n  if (options.all) {\n    return registryIndex\n      .map((entry) => entry.name)\n  }\n\n  if (options.components?.length) {\n    return options.components\n  }\n\n  const { components } = await prompts({\n    type: \"multiselect\",\n    name: \"components\",\n    message: \"Which components would you like to add?\",\n    hint: \"Space to select. A to toggle all. Enter to submit.\",\n    instructions: false,\n    choices: registryIndex\n      .map((entry) => ({\n        title: entry.name,\n        value: `/gh/${entry.author}/${entry.name}.json`,\n        selected: options.all ? true : options.components?.includes(entry.name),\n      })),\n  })\n\n  if (!components?.length) {\n    logger.warn(\"No components selected. Exiting.\")\n    logger.info(\"\")\n    process.exit(1)\n  }\n\n  const result = z.array(z.string()).safeParse(components)\n  if (!result.success) {\n    logger.error(\"\")\n    handleError(new Error(\"Something went wrong. Please try again.\"))\n    return []\n  }\n  return result.data\n}\n","import ora, { type Options } from \"ora\"\n\nexport function spinner(\n  text: Options[\"text\"],\n  options?: {\n    silent?: boolean\n  }\n) {\n  return ora({\n    text,\n    isSilent: options?.silent,\n  })\n}\n","import { existsSync, promises as fs } from \"fs\"\nimport path, { basename } from \"path\"\nimport { RegistryItem, registryItemFileSchema } from \"@/src/registry/schema\"\nimport { Config } from \"@/src/utils/get-config\"\nimport { getProjectInfo } from \"@/src/utils/get-project-info\"\nimport { highlighter } from \"@/src/utils/highlighter\"\nimport { logger } from \"@/src/utils/logger\"\nimport { spinner } from \"@/src/utils/spinner\"\nimport prompts from \"prompts\"\nimport { z } from \"zod\"\n\nexport async function updateFiles(\n  files: RegistryItem[\"files\"],\n  config: Config,\n  options: {\n    overwrite?: boolean\n    force?: boolean\n    silent?: boolean\n    rootSpinner?: ReturnType<typeof spinner>\n    isRemote?: boolean\n  }\n) {\n  if (!files?.length) {\n    return {\n      filesCreated: [],\n      filesUpdated: [],\n      filesSkipped: [],\n    }\n  }\n  options = {\n    overwrite: false,\n    force: false,\n    silent: false,\n    isRemote: false,\n    ...options,\n  }\n  const filesCreatedSpinner = spinner(`Updating files.`, {\n    silent: options.silent,\n  })?.start()\n\n  const [projectInfo] = await Promise.all([\n    getProjectInfo(config.resolvedPaths.cwd),\n  ])\n\n  const filesCreated = []\n  const filesUpdated = []\n  const filesSkipped = []\n\n  for (const file of files) {\n    if (!file.content) {\n      continue\n    }\n\n    let filePath = resolveFilePath(file, config, {\n      commonRoot: findCommonRoot(\n        files.map((f) => f.path),\n        file.path\n      ),\n    })\n    const fileName = basename(file.path)\n    const targetDir = path.dirname(filePath)\n\n    const existingFile = existsSync(filePath)\n    const content = file.content\n\n    // Skip the file if it already exists and the content is the same.\n    if (existingFile) {\n      const existingFileContent = await fs.readFile(filePath, \"utf-8\")\n      const [normalizedExisting, normalizedNew] = await Promise.all([\n        getNormalizedFileContent(existingFileContent),\n        getNormalizedFileContent(content),\n      ])\n      if (normalizedExisting === normalizedNew) {\n        filesSkipped.push(path.relative(config.resolvedPaths.cwd, filePath))\n        continue\n      }\n    }\n\n    if (existingFile && !options.overwrite) {\n      filesCreatedSpinner.stop()\n      if (options.rootSpinner) {\n        options.rootSpinner.stop()\n      }\n      const { overwrite } = await prompts({\n        type: \"confirm\",\n        name: \"overwrite\",\n        message: `The file ${highlighter.info(\n          fileName\n        )} already exists. Would you like to overwrite?`,\n        initial: false,\n      })\n\n      if (!overwrite) {\n        filesSkipped.push(path.relative(config.resolvedPaths.cwd, filePath))\n        if (options.rootSpinner) {\n          options.rootSpinner.start()\n        }\n        continue\n      }\n      filesCreatedSpinner?.start()\n      if (options.rootSpinner) {\n        options.rootSpinner.start()\n      }\n    }\n\n    // Create the target directory if it doesn't exist.\n    if (!existsSync(targetDir)) {\n      await fs.mkdir(targetDir, { recursive: true })\n    }\n\n    await fs.writeFile(filePath, content, \"utf-8\")\n    existingFile\n      ? filesUpdated.push(path.relative(config.resolvedPaths.cwd, filePath))\n      : filesCreated.push(path.relative(config.resolvedPaths.cwd, filePath))\n  }\n\n  const hasUpdatedFiles = filesCreated.length || filesUpdated.length\n  if (!hasUpdatedFiles && !filesSkipped.length) {\n    filesCreatedSpinner?.info(\"No files updated.\")\n  }\n\n  if (filesCreated.length) {\n    filesCreatedSpinner?.succeed(\n      `Created ${filesCreated.length} ${filesCreated.length === 1 ? \"file\" : \"files\"\n      }:`\n    )\n    if (!options.silent) {\n      for (const file of filesCreated) {\n        logger.log(`  - ${file}`)\n      }\n    }\n  } else {\n    filesCreatedSpinner?.stop()\n  }\n\n  if (filesUpdated.length) {\n    spinner(\n      `Updated ${filesUpdated.length} ${filesUpdated.length === 1 ? \"file\" : \"files\"\n      }:`,\n      {\n        silent: options.silent,\n      }\n    )?.info()\n    if (!options.silent) {\n      for (const file of filesUpdated) {\n        logger.log(`  - ${file}`)\n      }\n    }\n  }\n\n  if (filesSkipped.length) {\n    spinner(\n      `Skipped ${filesSkipped.length} ${filesUpdated.length === 1 ? \"file\" : \"files\"\n      }: (files might be identical, use --overwrite to overwrite)`,\n      {\n        silent: options.silent,\n      }\n    )?.info()\n    if (!options.silent) {\n      for (const file of filesSkipped) {\n        logger.log(`  - ${file}`)\n      }\n    }\n  }\n\n  if (!options.silent) {\n    logger.break()\n  }\n\n  return {\n    filesCreated,\n    filesUpdated,\n    filesSkipped,\n  }\n}\n\nexport function resolveFilePath(\n  file: z.infer<typeof registryItemFileSchema>,\n  config: Config,\n  options: {\n    isSrcDir?: boolean\n    commonRoot?: string\n  }\n) {\n  if (file.target) {\n    if (file.target.startsWith(\"~/\")) {\n      return path.join(config.resolvedPaths.cwd, file.target.replace(\"~/\", \"\"))\n    }\n\n    return path.join(config.resolvedPaths.cwd, file.target)\n  }\n}\n\nfunction resolveFileTargetDirectory(\n  file: z.infer<typeof registryItemFileSchema>,\n  config: Config\n) {\n  // if (file.type === \"registry:ui\") {\n  //   return config.resolvedPaths.ui\n  // }\n\n  // if (file.type === \"registry:lib\") {\n  //   return config.resolvedPaths.lib\n  // }\n\n  // if (file.type === \"registry:block\" || file.type === \"registry:component\") {\n  //   return config.resolvedPaths.components\n  // }\n\n  // if (file.type === \"registry:hook\") {\n  //   return config.resolvedPaths.hooks\n  // }\n\n  return config.resolvedPaths.cwd\n}\n\nexport function findCommonRoot(paths: string[], needle: string): string {\n  // Remove leading slashes for consistent handling\n  const normalizedPaths = paths.map((p) => p.replace(/^\\//, \"\"))\n  const normalizedNeedle = needle.replace(/^\\//, \"\")\n\n  // Get the directory path of the needle by removing the file name\n  const needleDir = normalizedNeedle.split(\"/\").slice(0, -1).join(\"/\")\n\n  // If needle is at root level, return empty string\n  if (!needleDir) {\n    return \"\"\n  }\n\n  // Split the needle directory into segments\n  const needleSegments = needleDir.split(\"/\")\n\n  // Start from the full path and work backwards\n  for (let i = needleSegments.length; i > 0; i--) {\n    const testPath = needleSegments.slice(0, i).join(\"/\")\n    // Check if this is a common root by verifying if any other paths start with it\n    const hasRelatedPaths = normalizedPaths.some(\n      (path) => path !== normalizedNeedle && path.startsWith(testPath + \"/\")\n    )\n    if (hasRelatedPaths) {\n      return \"/\" + testPath // Add leading slash back for the result\n    }\n  }\n\n  // If no common root found with other files, return the parent directory of the needle\n  return \"/\" + needleDir // Add leading slash back for the result\n}\n\nexport function resolveNestedFilePath(\n  filePath: string,\n  targetDir: string\n): string {\n  // Normalize paths by removing leading/trailing slashes\n  const normalizedFilePath = filePath.replace(/^\\/|\\/$/g, \"\")\n  const normalizedTargetDir = targetDir.replace(/^\\/|\\/$/g, \"\")\n\n  // Split paths into segments\n  const fileSegments = normalizedFilePath.split(\"/\")\n  const targetSegments = normalizedTargetDir.split(\"/\")\n\n  // Find the last matching segment from targetDir in filePath\n  const lastTargetSegment = targetSegments[targetSegments.length - 1]\n  const commonDirIndex = fileSegments.findIndex(\n    (segment) => segment === lastTargetSegment\n  )\n\n  if (commonDirIndex === -1) {\n    // Return just the filename if no common directory is found\n    return fileSegments[fileSegments.length - 1]\n  }\n\n  // Return everything after the common directory\n  return fileSegments.slice(commonDirIndex + 1).join(\"/\")\n}\n\nexport async function getNormalizedFileContent(content: string) {\n  return content.replace(/\\r\\n/g, \"\\n\").trim()\n}\n","import path from \"path\"\nimport { FRAMEWORKS, Framework } from \"@/src/utils/frameworks\"\nimport {\n  Config,\n  RawConfig,\n  getConfig,\n  resolveConfigPaths,\n} from \"@/src/utils/get-config\"\nimport { getPackageInfo } from \"@/src/utils/get-package-info\"\nimport fg from \"fast-glob\"\nimport fs from \"fs-extra\"\nimport { loadConfig } from \"tsconfig-paths\"\nimport { z } from \"zod\"\n\nexport type TailwindVersion = \"v3\" | \"v4\" | null\n\ntype ProjectInfo = {\n}\n\nconst PROJECT_SHARED_IGNORE = [\n  \"**/node_modules/**\",\n  \".next\",\n  \"public\",\n  \"dist\",\n  \"build\",\n]\n\nconst TS_CONFIG_SCHEMA = z.object({\n  compilerOptions: z.object({\n    paths: z.record(z.string().or(z.array(z.string()))),\n  }),\n})\n\nexport async function getProjectInfo(cwd: string): Promise<ProjectInfo | null> {\n  const isSrcDir = await fs.pathExists(path.resolve(cwd, \"src\"))\n\n  const type: ProjectInfo = {\n  }\n\n  return type\n}\n\nexport async function getTailwindVersion(\n  cwd: string\n): Promise<ProjectInfo[\"tailwindVersion\"]> {\n  const packageInfo = getPackageInfo(cwd)\n\n  if (\n    !packageInfo?.dependencies?.tailwindcss &&\n    !packageInfo?.devDependencies?.tailwindcss\n  ) {\n    return null\n  }\n\n  if (\n    /^(?:\\^|~)?3(?:\\.\\d+)*(?:-.*)?$/.test(\n      packageInfo?.dependencies?.tailwindcss ||\n      packageInfo?.devDependencies?.tailwindcss ||\n      \"\"\n    )\n  ) {\n    return \"v3\"\n  }\n\n  return \"v4\"\n}\n\nexport async function getTailwindCssFile(cwd: string) {\n  const [files, tailwindVersion] = await Promise.all([\n    fg.glob([\"**/*.css\", \"**/*.scss\"], {\n      cwd,\n      deep: 5,\n      ignore: PROJECT_SHARED_IGNORE,\n    }),\n    getTailwindVersion(cwd),\n  ])\n\n  if (!files.length) {\n    return null\n  }\n\n  const needle =\n    tailwindVersion === \"v4\" ? `@import \"tailwindcss\"` : \"@tailwind base\"\n  for (const file of files) {\n    const contents = await fs.readFile(path.resolve(cwd, file), \"utf8\")\n    if (\n      contents.includes(`@import \"tailwindcss\"`) ||\n      contents.includes(`@import 'tailwindcss'`) ||\n      contents.includes(`@tailwind base`)\n    ) {\n      return file\n    }\n  }\n\n  return null\n}\n\nexport async function getTailwindConfigFile(cwd: string) {\n  const files = await fg.glob(\"tailwind.config.*\", {\n    cwd,\n    deep: 3,\n    ignore: PROJECT_SHARED_IGNORE,\n  })\n\n  if (!files.length) {\n    return null\n  }\n\n  return files[0]\n}\n\nexport async function getTsConfigAliasPrefix(cwd: string) {\n  const tsConfig = await loadConfig(cwd)\n\n  if (\n    tsConfig?.resultType === \"failed\" ||\n    !Object.entries(tsConfig?.paths).length\n  ) {\n    return null\n  }\n\n  // This assume that the first alias is the prefix.\n  for (const [alias, paths] of Object.entries(tsConfig.paths)) {\n    if (\n      paths.includes(\"./*\") ||\n      paths.includes(\"./src/*\") ||\n      paths.includes(\"./app/*\") ||\n      paths.includes(\"./resources/js/*\") // Laravel.\n    ) {\n      return alias.replace(/\\/\\*$/, \"\") ?? null\n    }\n  }\n\n  // Use the first alias as the prefix.\n  return Object.keys(tsConfig?.paths)?.[0].replace(/\\/\\*$/, \"\") ?? null\n}\n\nexport async function isTypeScriptProject(cwd: string) {\n  const files = await fg.glob(\"tsconfig.*\", {\n    cwd,\n    deep: 1,\n    ignore: PROJECT_SHARED_IGNORE,\n  })\n\n  return files.length > 0\n}\n\nexport async function getTsConfig(cwd: string) {\n  for (const fallback of [\n    \"tsconfig.json\",\n    \"tsconfig.web.json\",\n    \"tsconfig.app.json\",\n  ]) {\n    const filePath = path.resolve(cwd, fallback)\n    if (!(await fs.pathExists(filePath))) {\n      continue\n    }\n\n    // We can't use fs.readJSON because it doesn't support comments.\n    const contents = await fs.readFile(filePath, \"utf8\")\n    const cleanedContents = contents.replace(/\\/\\*\\s*\\*\\//g, \"\")\n    const result = TS_CONFIG_SCHEMA.safeParse(JSON.parse(cleanedContents))\n\n    if (result.error) {\n      continue\n    }\n\n    return result.data\n  }\n\n  return null\n}\n\nexport async function getProjectConfig(\n  cwd: string,\n  defaultProjectInfo: ProjectInfo | null = null\n): Promise<Config | null> {\n  // Check for existing component config.\n  const [existingConfig, projectInfo] = await Promise.all([\n    getConfig(cwd),\n    !defaultProjectInfo\n      ? getProjectInfo(cwd)\n      : Promise.resolve(defaultProjectInfo),\n  ])\n\n  if (existingConfig) {\n    return existingConfig\n  }\n\n  if (\n    !projectInfo ||\n    !projectInfo.tailwindCssFile ||\n    (projectInfo.tailwindVersion === \"v3\" && !projectInfo.tailwindConfigFile)\n  ) {\n    return null\n  }\n\n  const config: RawConfig = {\n    $schema: \"https://ui.shadcn.com/schema.json\",\n    aliases: {\n      components: `${projectInfo.aliasPrefix}/components`,\n      ui: `${projectInfo.aliasPrefix}/components/ui`,\n      hooks: `${projectInfo.aliasPrefix}/hooks`,\n      lib: `${projectInfo.aliasPrefix}/lib`,\n      utils: `${projectInfo.aliasPrefix}/lib/utils`,\n    },\n  }\n\n  return await resolveConfigPaths(cwd, config)\n}\n\nexport async function getProjectTailwindVersionFromConfig(\n  config: Config\n): Promise<TailwindVersion> {\n  if (!config.resolvedPaths?.cwd) {\n    return \"v3\"\n  }\n\n  const projectInfo = await getProjectInfo(config.resolvedPaths.cwd)\n\n  if (!projectInfo?.tailwindVersion) {\n    return null\n  }\n\n  return projectInfo.tailwindVersion\n}\n","import path from \"path\"\nimport { getProjectInfo } from \"@/src/utils/get-project-info\"\nimport { highlighter } from \"@/src/utils/highlighter\"\nimport { resolveImport } from \"@/src/utils/resolve-import\"\nimport { cosmiconfig } from \"cosmiconfig\"\nimport fg from \"fast-glob\"\nimport { loadConfig } from \"tsconfig-paths\"\nimport { z } from \"zod\"\nimport { logger } from \"./logger\"\n\nexport const DEFAULT_STYLE = \"default\"\nexport const DEFAULT_COMPONENTS = \"@/components\"\nexport const DEFAULT_UTILS = \"@/lib/utils\"\nexport const DEFAULT_TAILWIND_CSS = \"app/globals.css\"\nexport const DEFAULT_TAILWIND_CONFIG = \"tailwind.config.js\"\nexport const DEFAULT_TAILWIND_BASE_COLOR = \"slate\"\n\n// TODO: Figure out if we want to support all cosmiconfig formats.\n// A simple components.json file would be nice.\nconst explorer = cosmiconfig(\"components\", {\n  searchPlaces: [\"components.json\"],\n})\n\nexport const rawConfigSchema = z\n  .object({\n    $schema: z.string().optional(),\n    aliases: z.object({\n      components: z.string().optional(),\n      utils: z.string().optional(),\n      ui: z.string().optional(),\n      lib: z.string().optional(),\n      hooks: z.string().optional(),\n    }),\n  })\n  .strict()\n\nexport type RawConfig = z.infer<typeof rawConfigSchema>\n\nexport const configSchema = rawConfigSchema.extend({\n  resolvedPaths: z.object({\n    cwd: z.string(),\n  }),\n})\n\nexport type Config = z.infer<typeof configSchema>\n\n// TODO: type the key.\n// Okay for now since I don't want a breaking change.\nexport const workspaceConfigSchema = z.record(configSchema)\n\nexport async function getConfig(cwd: string) {\n  const config = await getRawConfig(cwd)\n\n  if (!config) {\n    logger.error(`No config found in ${highlighter.info(cwd)}.`)\n    return null\n  }\n\n  return await resolveConfigPaths(cwd, config)\n}\n\nexport async function resolveConfigPaths(cwd: string, config: RawConfig) {\n\n  return configSchema.parse({\n    ...config,\n    resolvedPaths: {\n      cwd,\n    },\n  })\n}\n\nexport async function getRawConfig(cwd: string): Promise<Config | null> {\n  try {\n    return {\n      aliases: {},\n      resolvedPaths: {\n        cwd,\n      },\n    }\n  } catch (error) {\n    const componentPath = `${cwd}/components.json`\n    throw new Error(\n      `Invalid configuration found in ${highlighter.info(componentPath)}.`\n    )\n  }\n}\n\n// Note: we can check for -workspace.yaml or \"workspace\" in package.json.\n// Since cwd is not necessarily the root of the project.\n// We'll instead check if ui aliases resolve to a different root.\n// export async function getWorkspaceConfig(config: Config) {\n//   let resolvedAliases: any = {}\n\n//   for (const key of Object.keys(config.aliases)) {\n//     if (!isAliasKey(key, config)) {\n//       continue\n//     }\n\n//     const resolvedPath = config.resolvedPaths[key]\n//     const packageRoot = await findPackageRoot(\n//       config.resolvedPaths.cwd,\n//       resolvedPath\n//     )\n\n//     if (!packageRoot) {\n//       resolvedAliases[key] = config\n//       continue\n//     }\n\n//     resolvedAliases[key] = await getConfig(packageRoot)\n//   }\n\n//   const result = workspaceConfigSchema.safeParse(resolvedAliases)\n//   if (!result.success) {\n//     return null\n//   }\n\n//   return result.data\n// }\n\nexport async function findPackageRoot(cwd: string, resolvedPath: string) {\n  const commonRoot = findCommonRoot(cwd, resolvedPath)\n  const relativePath = path.relative(commonRoot, resolvedPath)\n\n  const packageRoots = await fg.glob(\"**/package.json\", {\n    cwd: commonRoot,\n    deep: 3,\n    ignore: [\"**/node_modules/**\", \"**/dist/**\", \"**/build/**\", \"**/public/**\"],\n  })\n\n  const matchingPackageRoot = packageRoots\n    .map((pkgPath) => path.dirname(pkgPath))\n    .find((pkgDir) => relativePath.startsWith(pkgDir))\n\n  return matchingPackageRoot ? path.join(commonRoot, matchingPackageRoot) : null\n}\n\nfunction isAliasKey(\n  key: string,\n  config: Config\n): key is keyof Config[\"aliases\"] {\n  return Object.keys(config.resolvedPaths)\n    .filter((key) => key !== \"utils\")\n    .includes(key)\n}\n\nexport function findCommonRoot(cwd: string, resolvedPath: string) {\n  const parts1 = cwd.split(path.sep)\n  const parts2 = resolvedPath.split(path.sep)\n  const commonParts = []\n\n  for (let i = 0; i < Math.min(parts1.length, parts2.length); i++) {\n    if (parts1[i] !== parts2[i]) {\n      break\n    }\n    commonParts.push(parts1[i])\n  }\n\n  return commonParts.join(path.sep)\n}","import path from \"path\"\nimport fs from \"fs-extra\"\nimport { type PackageJson } from \"type-fest\"\n\nexport function getPackageInfo(\n  cwd: string = \"\",\n  shouldThrow: boolean = true\n): PackageJson | null {\n  const packageJsonPath = path.join(cwd, \"package.json\")\n\n  return fs.readJSONSync(packageJsonPath, {\n    throws: shouldThrow,\n  }) as PackageJson\n}\n","import path from \"path\"\nimport {\n  fetchRegistry,\n  getRegistryParentMap,\n  getRegistryTypeAliasMap,\n  registryResolveItemsTree,\n  resolveRegistryItems,\n} from \"@/src/registry/api\"\nimport { registryItemSchema } from \"@/src/registry/schema\"\nimport {\n  configSchema,\n  findCommonRoot,\n  findPackageRoot,\n  workspaceConfigSchema,\n  type Config,\n} from \"@/src/utils/get-config\"\nimport { getProjectTailwindVersionFromConfig } from \"@/src/utils/get-project-info\"\nimport { handleError } from \"@/src/utils/handle-error\"\nimport { logger } from \"@/src/utils/logger\"\nimport { spinner } from \"@/src/utils/spinner\"\nimport { updateCssVars } from \"@/src/utils/updaters/update-css-vars\"\nimport { updateDependencies } from \"@/src/utils/updaters/update-dependencies\"\nimport { updateFiles } from \"@/src/utils/updaters/update-files\"\nimport { updateTailwindConfig } from \"@/src/utils/updaters/update-tailwind-config\"\nimport { z } from \"zod\"\n\nexport async function addComponents(\n  components: string[],\n  config: Config,\n  options: {\n    overwrite?: boolean\n    silent?: boolean\n    isNewProject?: boolean\n  }\n) {\n  options = {\n    overwrite: false,\n    silent: false,\n    isNewProject: false,\n    ...options,\n  }\n\n  // const workspaceConfig = await getWorkspaceConfig(config)\n  // if (\n  //   workspaceConfig &&\n  //   workspaceConfig.ui &&\n  //   workspaceConfig.ui.resolvedPaths.cwd !== config.resolvedPaths.cwd\n  // ) {\n  //   return await addWorkspaceComponents(components, config, workspaceConfig, {\n  //     ...options,\n  //     isRemote:\n  //       components?.length === 1 && !!components[0].match(/\\/chat\\/b\\//),\n  //   })\n  // }\n\n  return await addProjectComponents(components, config, options)\n}\n\nasync function addProjectComponents(\n  components: string[],\n  config: z.infer<typeof configSchema>,\n  options: {\n    overwrite?: boolean\n    silent?: boolean\n    isNewProject?: boolean\n  }\n) {\n  const registrySpinner = spinner(`Checking registry.`, {\n    silent: options.silent,\n  })?.start()\n  const tree = await registryResolveItemsTree(components, config)\n  if (!tree) {\n    registrySpinner?.fail()\n    return handleError(new Error(\"Failed to fetch components from registry.\"))\n  }\n  registrySpinner?.succeed()\n\n  await updateFiles(tree.files, config, {\n    overwrite: options.overwrite,\n    silent: options.silent,\n  })\n\n  if (tree.docs) {\n    logger.info(tree.docs)\n  }\n}","import { existsSync, promises as fs } from \"fs\"\nimport path from \"path\"\nimport {\n  fetchTree,\n  getItemTargetPath,\n  getRegistryIndex,\n} from \"@/src/registry/api\"\nimport { registryIndexSchema } from \"@/src/registry/schema\"\nimport { Config, getConfig } from \"@/src/utils/get-config\"\nimport { handleError } from \"@/src/utils/handle-error\"\nimport { highlighter } from \"@/src/utils/highlighter\"\nimport { logger } from \"@/src/utils/logger\"\nimport { transform } from \"@/src/utils/transformers\"\nimport { Command } from \"commander\"\nimport { diffLines, type Change } from \"diff\"\nimport { z } from \"zod\"\n\nconst updateOptionsSchema = z.object({\n  component: z.string().optional(),\n  yes: z.boolean(),\n  cwd: z.string(),\n  path: z.string().optional(),\n})\n\nexport const diff = new Command()\n  .name(\"diff\")\n  .description(\"check for updates against the registry\")\n  .argument(\"[component]\", \"the component name\")\n  .option(\"-y, --yes\", \"skip confirmation prompt.\", false)\n  .option(\n    \"-c, --cwd <cwd>\",\n    \"the working directory. defaults to the current directory.\",\n    process.cwd()\n  )\n  .action(async (name, opts) => {\n    try {\n      const options = updateOptionsSchema.parse({\n        component: name,\n        ...opts,\n      })\n\n      const cwd = path.resolve(options.cwd)\n\n      if (!existsSync(cwd)) {\n        logger.error(`The path ${cwd} does not exist. Please try again.`)\n        process.exit(1)\n      }\n\n      const config = await getConfig(cwd)\n      if (!config) {\n        logger.warn(\n          `Configuration is missing. Please run ${highlighter.success(\n            `init`\n          )} to create a components.json file.`\n        )\n        process.exit(1)\n      }\n\n      const registryIndex = await getRegistryIndex()\n\n      if (!registryIndex) {\n        handleError(new Error(\"Failed to fetch registry index.\"))\n        process.exit(1)\n      }\n\n      if (!options.component) {\n        const targetDir = config.resolvedPaths.components\n\n        // Find all components that exist in the project.\n        const projectComponents = registryIndex.filter((item) => {\n          for (const file of item.files ?? []) {\n            const filePath = path.resolve(\n              targetDir,\n              typeof file === \"string\" ? file : file.path\n            )\n            if (existsSync(filePath)) {\n              return true\n            }\n          }\n\n          return false\n        })\n\n        // Check for updates.\n        const componentsWithUpdates = []\n        for (const component of projectComponents) {\n          const changes = await diffComponent(component, config)\n          if (changes.length) {\n            componentsWithUpdates.push({\n              name: component.name,\n              changes,\n            })\n          }\n        }\n\n        if (!componentsWithUpdates.length) {\n          logger.info(\"No updates found.\")\n          process.exit(0)\n        }\n\n        logger.info(\"The following components have updates available:\")\n        for (const component of componentsWithUpdates) {\n          logger.info(`- ${component.name}`)\n          for (const change of component.changes) {\n            logger.info(`  - ${change.filePath}`)\n          }\n        }\n        logger.break()\n        logger.info(\n          `Run ${highlighter.success(`diff <component>`)} to see the changes.`\n        )\n        process.exit(0)\n      }\n\n      // Show diff for a single component.\n      const component = registryIndex.find(\n        (item) => item.name === options.component\n      )\n\n      if (!component) {\n        logger.error(\n          `The component ${highlighter.success(\n            options.component\n          )} does not exist.`\n        )\n        process.exit(1)\n      }\n\n      const changes = await diffComponent(component, config)\n\n      if (!changes.length) {\n        logger.info(`No updates found for ${options.component}.`)\n        process.exit(0)\n      }\n\n      for (const change of changes) {\n        logger.info(`- ${change.filePath}`)\n        await printDiff(change.patch)\n        logger.info(\"\")\n      }\n    } catch (error) {\n      handleError(error)\n    }\n  })\n\nasync function diffComponent(\n  component: z.infer<typeof registryIndexSchema>[number],\n  config: Config\n) {\n  const payload = await fetchTree(config.style, [component])\n\n  if (!payload) {\n    return []\n  }\n\n  const changes = []\n\n  for (const item of payload) {\n    const targetDir = await getItemTargetPath(config, item)\n\n    if (!targetDir) {\n      continue\n    }\n\n    for (const file of item.files ?? []) {\n      const filePath = path.resolve(\n        targetDir,\n        typeof file === \"string\" ? file : file.path\n      )\n\n      if (!existsSync(filePath)) {\n        continue\n      }\n\n      const fileContent = await fs.readFile(filePath, \"utf8\")\n\n      if (typeof file === \"string\" || !file.content) {\n        continue\n      }\n\n      const registryContent = await transform({\n        filename: file.path,\n        raw: file.content,\n        config,\n      })\n\n      const patch = diffLines(registryContent as string, fileContent)\n      if (patch.length > 1) {\n        changes.push({\n          filePath,\n          patch,\n        })\n      }\n    }\n  }\n\n  return changes\n}\n\nasync function printDiff(diff: Change[]) {\n  diff.forEach((part) => {\n    if (part) {\n      if (part.added) {\n        return process.stdout.write(highlighter.success(part.value))\n      }\n      if (part.removed) {\n        return process.stdout.write(highlighter.error(part.value))\n      }\n\n      return process.stdout.write(part.value)\n    }\n  })\n}\n","import { promises as fs } from \"fs\"\nimport { tmpdir } from \"os\"\nimport path from \"path\"\nimport { registryBaseColorSchema } from \"@/src/registry/schema\"\nimport { Config } from \"@/src/utils/get-config\"\nimport { transformJsx } from \"@/src/utils/transformers/transform-jsx\"\nimport { Project, ScriptKind, type SourceFile } from \"ts-morph\"\nimport { z } from \"zod\"\n\nexport type TransformOpts = {\n  filename: string\n  raw: string\n  config: Config\n  baseColor?: z.infer<typeof registryBaseColorSchema>\n  transformJsx?: boolean\n  isRemote?: boolean\n}\n\nexport type Transformer<Output = SourceFile> = (\n  opts: TransformOpts & {\n    sourceFile: SourceFile\n  }\n) => Promise<Output>\n\nconst project = new Project({\n  compilerOptions: {},\n})\n\nasync function createTempSourceFile(filename: string) {\n  const dir = await fs.mkdtemp(path.join(tmpdir(), \"shadcn-\"))\n  return path.join(dir, filename)\n}\n\nexport async function transform(\n  opts: TransformOpts,\n  transformers: Transformer[] = [\n  ]\n) {\n  const tempFile = await createTempSourceFile(opts.filename)\n  const sourceFile = project.createSourceFile(tempFile, opts.raw, {\n    scriptKind: ScriptKind.TSX,\n  })\n\n  for (const transformer of transformers) {\n    await transformer({ sourceFile, ...opts })\n  }\n\n  if (opts.transformJsx) {\n    return await transformJsx({\n      sourceFile,\n      ...opts,\n    })\n  }\n\n  return sourceFile.getText()\n}\n","import { type Transformer } from \"@/src/utils/transformers\"\nimport { transformFromAstSync } from \"@babel/core\"\nimport { ParserOptions, parse } from \"@babel/parser\"\n// @ts-ignore\nimport transformTypescript from \"@babel/plugin-transform-typescript\"\nimport * as recast from \"recast\"\n\n// TODO.\n// I'm using recast for the AST here.\n// Figure out if ts-morph AST is compatible with Babel.\n\n// This is a copy of the babel options from recast/parser.\n// The goal here is to tolerate as much syntax as possible.\n// We want to be able to parse any valid tsx code.\n// See https://github.com/benjamn/recast/blob/master/parsers/_babel_options.ts.\nconst PARSE_OPTIONS: ParserOptions = {\n  sourceType: \"module\",\n  allowImportExportEverywhere: true,\n  allowReturnOutsideFunction: true,\n  startLine: 1,\n  tokens: true,\n  plugins: [\n    \"asyncGenerators\",\n    \"bigInt\",\n    \"classPrivateMethods\",\n    \"classPrivateProperties\",\n    \"classProperties\",\n    \"classStaticBlock\",\n    \"decimal\",\n    \"decorators-legacy\",\n    \"doExpressions\",\n    \"dynamicImport\",\n    \"exportDefaultFrom\",\n    \"exportNamespaceFrom\",\n    \"functionBind\",\n    \"functionSent\",\n    \"importAssertions\",\n    \"importMeta\",\n    \"nullishCoalescingOperator\",\n    \"numericSeparator\",\n    \"objectRestSpread\",\n    \"optionalCatchBinding\",\n    \"optionalChaining\",\n    [\n      \"pipelineOperator\",\n      {\n        proposal: \"minimal\",\n      },\n    ],\n    [\n      \"recordAndTuple\",\n      {\n        syntaxType: \"hash\",\n      },\n    ],\n    \"throwExpressions\",\n    \"topLevelAwait\",\n    \"v8intrinsic\",\n    \"typescript\",\n    \"jsx\",\n  ],\n}\n\nexport const transformJsx: Transformer<string> = async ({\n  sourceFile,\n  config,\n}) => {\n  const output = sourceFile.getFullText()\n\n  if (config.tsx) {\n    return output\n  }\n\n  const ast = recast.parse(output, {\n    parser: {\n      parse: (code: string) => {\n        return parse(code, PARSE_OPTIONS)\n      },\n    },\n  })\n\n  const result = transformFromAstSync(ast, output, {\n    cloneInputAst: false,\n    code: false,\n    ast: true,\n    plugins: [transformTypescript],\n    configFile: false,\n  })\n\n  if (!result || !result.ast) {\n    throw new Error(\"Failed to transform JSX\")\n  }\n\n  return recast.print(result.ast).code\n}\n","import { getConfig } from \"@/src/utils/get-config\"\nimport { getProjectInfo } from \"@/src/utils/get-project-info\"\nimport { logger } from \"@/src/utils/logger\"\nimport { Command } from \"commander\"\n\nexport const info = new Command()\n  .name(\"info\")\n  .description(\"get information about your project\")\n  .option(\n    \"-c, --cwd <cwd>\",\n    \"the working directory. defaults to the current directory.\",\n    process.cwd()\n  )\n  .action(async (opts) => {\n    logger.info(\"> project info\")\n    console.log(await getProjectInfo(opts.cwd))\n    logger.break()\n    logger.info(\"> components.json\")\n    console.log(await getConfig(opts.cwd))\n  })\n","#!/usr/bin/env node\nimport { add } from \"@/src/commands/add\"\nimport { diff } from \"@/src/commands/diff\"\nimport { info } from \"@/src/commands/info\"\nimport { Command } from \"commander\"\n\nimport packageJson from \"../package.json\"\n\nprocess.on(\"SIGINT\", () => process.exit(0))\nprocess.on(\"SIGTERM\", () => process.exit(0))\n\nasync function main() {\n  const program = new Command()\n    .name(\"shadcn\")\n    .description(\"add components and dependencies to your project\")\n    .version(\n      packageJson.version || \"1.0.0\",\n      \"-v, --version\",\n      \"display the version number\"\n    )\n\n  program\n    .addCommand(add)\n    .addCommand(diff)\n    .addCommand(info)\n\n  program.parse()\n}\n\nmain()\n\nexport * from \"./registry/api\"\n","{\n  \"name\": \"ctxs\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Add context to your apps\",\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"license\": \"MIT\",\n  \"author\": {\n    \"name\": \"martinklepsch\",\n    \"url\": \"https://x.com/martinklepsch\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/ctxs-ai/cli.git\"\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"keywords\": [\n    \"llm\",\n    \"context-window\",\n    \"prompts\",\n    \"shadcn\"\n  ],\n  \"type\": \"module\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"default\": \"./dist/index.js\"\n    },\n    \"./registry\": {\n      \"types\": \"./dist/registry/index.d.ts\",\n      \"default\": \"./dist/registry/index.js\"\n    }\n  },\n  \"bin\": \"./dist/index.js\",\n  \"scripts\": {\n    \"dev\": \"tsup --watch\",\n    \"build\": \"tsup\",\n    \"typecheck\": \"tsc --noEmit\",\n    \"clean\": \"rimraf dist && rimraf components\",\n    \"start:dev\": \"cross-env REGISTRY_URL=http://localhost:4321/r node dist/index.js\",\n    \"start:prod\": \"cross-env REGISTRY_URL=https://ui.shadcn.com/r node dist/index.js\",\n    \"start\": \"node dist/index.js\",\n    \"format:write\": \"prettier --write \\\"**/*.{ts,tsx,mdx}\\\" --cache\",\n    \"format:check\": \"prettier --check \\\"**/*.{ts,tsx,mdx}\\\" --cache\",\n    \"release\": \"changeset version\",\n    \"pub:beta\": \"pnpm build && pnpm publish --no-git-checks --access public --tag beta\",\n    \"pub:next\": \"pnpm build && pnpm publish --no-git-checks --access public --tag next\",\n    \"pub:release\": \"pnpm build && pnpm publish --access public\",\n    \"test\": \"vitest run\",\n    \"test:dev\": \"REGISTRY_URL=http://localhost:4321/r vitest run\"\n  },\n  \"dependencies\": {\n    \"@antfu/ni\": \"^23.2.0\",\n    \"@babel/core\": \"^7.22.1\",\n    \"@babel/parser\": \"^7.22.6\",\n    \"@babel/plugin-transform-typescript\": \"^7.22.5\",\n    \"commander\": \"^10.0.0\",\n    \"cosmiconfig\": \"^8.1.3\",\n    \"deepmerge\": \"^4.3.1\",\n    \"diff\": \"^5.1.0\",\n    \"execa\": \"^7.0.0\",\n    \"fast-glob\": \"^3.3.2\",\n    \"fs-extra\": \"^11.1.0\",\n    \"https-proxy-agent\": \"^6.2.0\",\n    \"kleur\": \"^4.1.5\",\n    \"msw\": \"^2.7.1\",\n    \"node-fetch\": \"^3.3.0\",\n    \"ora\": \"^6.1.2\",\n    \"postcss\": \"^8.4.24\",\n    \"prompts\": \"^2.4.2\",\n    \"recast\": \"^0.23.2\",\n    \"stringify-object\": \"^5.0.0\",\n    \"ts-morph\": \"^18.0.0\",\n    \"tsconfig-paths\": \"^4.2.0\",\n    \"zod\": \"^3.20.2\"\n  },\n  \"devDependencies\": {\n    \"@types/babel__core\": \"^7.20.1\",\n    \"@types/diff\": \"^5.0.3\",\n    \"@types/fs-extra\": \"^11.0.1\",\n    \"@types/prompts\": \"^2.4.2\",\n    \"@types/stringify-object\": \"^4.0.5\",\n    \"rimraf\": \"^6.0.1\",\n    \"tsup\": \"^6.6.3\",\n    \"type-fest\": \"^3.8.0\",\n    \"typescript\": \"^4.9.3\"\n  }\n}\n"]}